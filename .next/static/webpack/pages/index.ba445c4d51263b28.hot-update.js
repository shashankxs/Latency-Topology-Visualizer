"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./lib/latencyProvider.ts":
/*!********************************!*\
  !*** ./lib/latencyProvider.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   latencyProvider: function() { return /* binding */ latencyProvider; }\n/* harmony export */ });\n/* harmony import */ var _data_exchanges__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/exchanges */ \"./data/exchanges.ts\");\n\n// simple haversine distance\nfunction haversine(a, b) {\n    const toRad = (d)=>d * Math.PI / 180;\n    const R = 6371;\n    const dLat = toRad(b.latitude - a.latitude);\n    const dLon = toRad(b.longitude - a.longitude);\n    const lat1 = toRad(a.latitude);\n    const lat2 = toRad(b.latitude);\n    const sinDlat = Math.sin(dLat / 2);\n    const sinDlon = Math.sin(dLon / 2);\n    const v = sinDlat * sinDlat + Math.cos(lat1) * Math.cos(lat2) * sinDlon * sinDlon;\n    const c = 2 * Math.atan2(Math.sqrt(v), Math.sqrt(1 - v));\n    return R * c;\n}\n// Small per-host cache to avoid redundant calls within TTL\nconst HOST_CACHE_TTL_MS = 4000;\nconst hostCache = new Map();\n// attempt to fetch latency from latencyapi.com; extract host from URL\nasync function probeUrl(url) {\n    let timeoutMs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2500;\n    const host = new URL(url).hostname;\n    // cache check\n    const cached = hostCache.get(host);\n    const now = Date.now();\n    if (cached && now - cached.ts < HOST_CACHE_TTL_MS) {\n        return cached.ms;\n    }\n    const apiUrl = \"https://latencyapi.com/ping?host=\".concat(encodeURIComponent(host));\n    const controller = new AbortController();\n    const id = setTimeout(()=>controller.abort(), timeoutMs);\n    try {\n        const response = await fetch(apiUrl, {\n            cache: \"no-store\",\n            credentials: \"omit\",\n            mode: \"cors\",\n            signal: controller.signal\n        });\n        if (!response.ok) throw new Error(\"API error: \".concat(response.status));\n        const data = await response.json().catch(()=>({}));\n        const latency = typeof (data === null || data === void 0 ? void 0 : data.latency) === \"number\" ? data.latency : NaN;\n        if (!Number.isFinite(latency) || latency <= 0) {\n            throw new Error(\"Invalid latency data\");\n        }\n        const ms = Math.max(1, Math.round(latency));\n        hostCache.set(host, {\n            ts: now,\n            ms\n        });\n        return ms;\n    } finally{\n        clearTimeout(id);\n    }\n}\n// Lightweight concurrency limiter\nasync function withConcurrency(items, limit, worker) {\n    const executing = [];\n    for(let i = 0; i < items.length; i++){\n        const p = worker(items[i], i);\n        executing.push(p);\n        if (executing.length >= limit) {\n            await Promise.race(executing).catch(()=>undefined);\n            // remove settled\n            for(let j = executing.length - 1; j >= 0; j--){\n                if (executing[j].settled) continue;\n            }\n            // compact by filtering settled promises\n            for(let k = executing.length - 1; k >= 0; k--){\n                if (executing[k].__done__) {\n                    executing.splice(k, 1);\n                }\n            }\n        }\n        // mark completion\n        p.then(()=>p.__done__ = true, ()=>p.__done__ = true);\n    }\n    // await remaining\n    await Promise.allSettled(executing);\n}\nclass ProbeLatencyService {\n    start() {\n        if (this.running) return;\n        this.running = true;\n        // seed history for pairs\n        const now = Date.now();\n        for(let i = 0; i < _data_exchanges__WEBPACK_IMPORTED_MODULE_0__.EXCHANGE_SERVERS.length; i++){\n            for(let j = 0; j < _data_exchanges__WEBPACK_IMPORTED_MODULE_0__.EXCHANGE_SERVERS.length; j++){\n                if (i === j) continue;\n                const key = this.key(_data_exchanges__WEBPACK_IMPORTED_MODULE_0__.EXCHANGE_SERVERS[i].id, _data_exchanges__WEBPACK_IMPORTED_MODULE_0__.EXCHANGE_SERVERS[j].id);\n                if (!this.history[key]) {\n                    this.history[key] = [];\n                    for(let k = 60; k >= 0; k--){\n                        const ts = now - k * this.interval;\n                        const ms = this.syntheticLatency(_data_exchanges__WEBPACK_IMPORTED_MODULE_0__.EXCHANGE_SERVERS[i], _data_exchanges__WEBPACK_IMPORTED_MODULE_0__.EXCHANGE_SERVERS[j]);\n                        this.history[key].push({\n                            ts,\n                            ms\n                        });\n                    }\n                }\n            }\n        }\n        this.tick();\n    }\n    stop() {\n        this.running = false;\n        if (this._timer !== undefined) {\n            clearTimeout(this._timer);\n            this._timer = undefined;\n        }\n    }\n    subscribe(cb) {\n        this.subscribers.push(cb);\n        return ()=>{\n            this.subscribers = this.subscribers.filter((s)=>s !== cb);\n        };\n    }\n    getHistory(from, to, sinceTs) {\n        const key = this.key(from, to);\n        const h = this.history[key] || [];\n        if (!sinceTs) return h;\n        return h.filter((p)=>p.ts >= sinceTs);\n    }\n    key(a, b) {\n        return \"\".concat(a, \"__\").concat(b);\n    }\n    async tick() {\n        if (this.ticking) {\n            // prevent overlap; schedule next\n            if (this.running) {\n                this._timer = window.setTimeout(()=>this.tick(), this.interval);\n            }\n            return;\n        }\n        this.ticking = true;\n        const updates = [];\n        const tasks = [];\n        for(let i = 0; i < _data_exchanges__WEBPACK_IMPORTED_MODULE_0__.EXCHANGE_SERVERS.length; i++){\n            for(let j = 0; j < _data_exchanges__WEBPACK_IMPORTED_MODULE_0__.EXCHANGE_SERVERS.length; j++){\n                if (i === j) continue;\n                const from = _data_exchanges__WEBPACK_IMPORTED_MODULE_0__.EXCHANGE_SERVERS[i];\n                const to = _data_exchanges__WEBPACK_IMPORTED_MODULE_0__.EXCHANGE_SERVERS[j];\n                // If you later add probes?: string[] to ExchangeServer, safely combine and dedupe here.\n                const candidates = new Set();\n                // Example (uncomment when probes exist):\n                // (from.probes ?? []).forEach((u) => candidates.add(u));\n                // (to.probes ?? []).forEach((u) => candidates.add(u));\n                tasks.push({\n                    from,\n                    to,\n                    probeHosts: Array.from(candidates)\n                });\n            }\n        }\n        // Worker executes per pair\n        const worker = async (task)=>{\n            const { from, to, probeHosts } = task;\n            let ms = null;\n            // Probe through candidates if any; else use synthetic\n            for (const url of probeHosts){\n                try {\n                    const rtt = await probeUrl(url, 2000);\n                    ms = rtt;\n                    break;\n                } catch (e) {\n                // try next candidate\n                }\n            }\n            if (ms === null) {\n                ms = this.syntheticLatency(from, to);\n            }\n            const key = this.key(from.id, to.id);\n            const point = {\n                ts: Date.now(),\n                ms\n            };\n            if (!this.history[key]) this.history[key] = [];\n            this.history[key].push(point);\n            if (this.history[key].length > 1500) this.history[key].shift();\n            updates.push({\n                from: from.id,\n                to: to.id,\n                ms\n            });\n        };\n        // Constrain concurrency; 10 is conservative for browsers\n        try {\n            await withConcurrency(tasks, 10, worker);\n        } catch (e) {\n        // swallow; demo-friendly\n        }\n        if (updates.length) {\n            // Notify subscribers\n            this.subscribers.forEach((s)=>{\n                try {\n                    s(updates);\n                } catch (e) {\n                // ignore subscriber errors\n                }\n            });\n        }\n        this.ticking = false;\n        if (this.running) {\n            this._timer = window.setTimeout(()=>this.tick(), this.interval);\n        }\n    }\n    syntheticLatency(a, b) {\n        const distKm = haversine(a, b);\n        // Base: distance-based + small noise\n        const base = Math.max(5, distKm * 0.6 + Math.random() * 20);\n        // Cross-provider penalty to simulate inter-cloud paths\n        const providerPenalty = a.provider !== b.provider ? 8 + Math.random() * 18 : 0;\n        return Math.round(base + providerPenalty);\n    }\n    constructor(){\n        this.interval = 5000;\n        this.subscribers = [];\n        this.history = {};\n        this.running = false;\n        this.ticking = false // prevent overlapping ticks\n        ;\n    }\n}\nconst latencyProvider = new ProbeLatencyService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VUFBTTtnQkFDTiwyQkFBMkI7Z0JBQzdCO1lBQ0Y7UUFDRjtRQUVBLElBQUksQ0FBQ0YsT0FBTyxHQUFHO1FBRWYsSUFBSSxJQUFJLENBQUNsQixPQUFPLEVBQUU7WUFDaEIsSUFBSSxDQUFDTyxNQUFNLEdBQUdZLE9BQU85RCxVQUFVLENBQUMsSUFBTSxJQUFJLENBQUNnRCxJQUFJLElBQUksSUFBSSxDQUFDRixRQUFRO1FBQ2xFO0lBQ0Y7SUFFUUMsaUJBQWlCeEYsQ0FBaUIsRUFBRUMsQ0FBaUIsRUFBRTtRQUM3RCxNQUFNa0gsU0FBU3BILFVBQVVDLEdBQUdDO1FBQzVCLHFDQUFxQztRQUNyQyxNQUFNbUgsT0FBT2hILEtBQUt1RCxHQUFHLENBQUMsR0FBR3dELFNBQVMsTUFBTS9HLEtBQUtpSCxNQUFNLEtBQUs7UUFDeEQsdURBQXVEO1FBQ3ZELE1BQU1DLGtCQUFrQnRILEVBQUV1SCxRQUFRLEtBQUt0SCxFQUFFc0gsUUFBUSxHQUFHLElBQUluSCxLQUFLaUgsTUFBTSxLQUFLLEtBQUs7UUFDN0UsT0FBT2pILEtBQUt3RCxLQUFLLENBQUN3RCxPQUFPRTtJQUMzQjs7YUF0SkEvQixXQUFXO2FBQ1hPLGNBQTRCLEVBQUU7YUFDOUJSLFVBQTJDLENBQUM7YUFFcENGLFVBQVU7YUFDVmtCLFVBQVUsTUFBTyw0QkFBNEI7OztBQWtKdkQ7QUFFTyxNQUFNa0Isa0JBQWtCLElBQUl0QyxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2xhdGVuY3lQcm92aWRlci50cz9iODgzIl0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5pbXBvcnQgeyBFWENIQU5HRV9TRVJWRVJTLCBFeGNoYW5nZVNlcnZlciB9IGZyb20gXCIuLi9kYXRhL2V4Y2hhbmdlc1wiO1xyXG5cclxudHlwZSBQYWlyS2V5ID0gc3RyaW5nO1xyXG5cclxuZXhwb3J0IHR5cGUgTGF0ZW5jeVBvaW50ID0ge1xyXG4gIHRzOiBudW1iZXI7XHJcbiAgbXM6IG51bWJlcjtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIExhdGVuY3lVcGRhdGUgPSB7XHJcbiAgZnJvbTogc3RyaW5nO1xyXG4gIHRvOiBzdHJpbmc7XHJcbiAgbXM6IG51bWJlcjtcclxufTtcclxuXHJcblxyXG50eXBlIFN1YnNjcmliZXIgPSAodXBkYXRlczogTGF0ZW5jeVVwZGF0ZVtdKSA9PiB2b2lkO1xyXG5cclxuLy8gc2ltcGxlIGhhdmVyc2luZSBkaXN0YW5jZVxyXG5mdW5jdGlvbiBoYXZlcnNpbmUoYTogeyBsYXRpdHVkZTogbnVtYmVyOyBsb25naXR1ZGU6IG51bWJlciB9LCBiOiB7IGxhdGl0dWRlOiBudW1iZXI7IGxvbmdpdHVkZTogbnVtYmVyIH0pIHtcclxuICBjb25zdCB0b1JhZCA9IChkOiBudW1iZXIpID0+IChkICogTWF0aC5QSSkgLyAxODA7XHJcbiAgY29uc3QgUiA9IDYzNzE7XHJcbiAgY29uc3QgZExhdCA9IHRvUmFkKGIubGF0aXR1ZGUgLSBhLmxhdGl0dWRlKTtcclxuICBjb25zdCBkTG9uID0gdG9SYWQoYi5sb25naXR1ZGUgLSBhLmxvbmdpdHVkZSk7XHJcbiAgY29uc3QgbGF0MSA9IHRvUmFkKGEubGF0aXR1ZGUpO1xyXG4gIGNvbnN0IGxhdDIgPSB0b1JhZChiLmxhdGl0dWRlKTtcclxuICBjb25zdCBzaW5EbGF0ID0gTWF0aC5zaW4oZExhdCAvIDIpO1xyXG4gIGNvbnN0IHNpbkRsb24gPSBNYXRoLnNpbihkTG9uIC8gMik7XHJcbiAgY29uc3QgdiA9IHNpbkRsYXQgKiBzaW5EbGF0ICsgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIHNpbkRsb24gKiBzaW5EbG9uO1xyXG4gIGNvbnN0IGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQodiksIE1hdGguc3FydCgxIC0gdikpO1xyXG4gIHJldHVybiBSICogYztcclxufVxyXG5cclxuLy8gU21hbGwgcGVyLWhvc3QgY2FjaGUgdG8gYXZvaWQgcmVkdW5kYW50IGNhbGxzIHdpdGhpbiBUVExcclxuY29uc3QgSE9TVF9DQUNIRV9UVExfTVMgPSA0MDAwO1xyXG5jb25zdCBob3N0Q2FjaGUgPSBuZXcgTWFwPHN0cmluZywgeyB0czogbnVtYmVyOyBtczogbnVtYmVyIH0+KCk7XHJcblxyXG4vLyBhdHRlbXB0IHRvIGZldGNoIGxhdGVuY3kgZnJvbSBsYXRlbmN5YXBpLmNvbTsgZXh0cmFjdCBob3N0IGZyb20gVVJMXHJcbmFzeW5jIGZ1bmN0aW9uIHByb2JlVXJsKHVybDogc3RyaW5nLCB0aW1lb3V0TXMgPSAyNTAwKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICBjb25zdCBob3N0ID0gbmV3IFVSTCh1cmwpLmhvc3RuYW1lO1xyXG5cclxuICAvLyBjYWNoZSBjaGVja1xyXG4gIGNvbnN0IGNhY2hlZCA9IGhvc3RDYWNoZS5nZXQoaG9zdCk7XHJcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICBpZiAoY2FjaGVkICYmIG5vdyAtIGNhY2hlZC50cyA8IEhPU1RfQ0FDSEVfVFRMX01TKSB7XHJcbiAgICByZXR1cm4gY2FjaGVkLm1zO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgYXBpVXJsID0gYGh0dHBzOi8vbGF0ZW5jeWFwaS5jb20vcGluZz9ob3N0PSR7ZW5jb2RlVVJJQ29tcG9uZW50KGhvc3QpfWA7XHJcbiAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0TXMpO1xyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcGlVcmwsIHtcclxuICAgICAgY2FjaGU6IFwibm8tc3RvcmVcIixcclxuICAgICAgY3JlZGVudGlhbHM6IFwib21pdFwiLFxyXG4gICAgICBtb2RlOiBcImNvcnNcIixcclxuICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKGBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG5cclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9IGFzIGFueSkpO1xyXG4gICAgY29uc3QgbGF0ZW5jeSA9IHR5cGVvZiBkYXRhPy5sYXRlbmN5ID09PSBcIm51bWJlclwiID8gZGF0YS5sYXRlbmN5IDogTmFOO1xyXG4gICAgaWYgKCEgTnVtYmVyLmlzRmluaXRlKGxhdGVuY3kpIHx8IGxhdGVuY3kgPD0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxhdGVuY3kgZGF0YVwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtcyA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQobGF0ZW5jeSkpO1xyXG4gICAgaG9zdENhY2hlLnNldChob3N0LCB7IHRzOiBub3csIG1zIH0pO1xyXG4gICAgcmV0dXJuIG1zO1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICBjbGVhclRpbWVvdXQoaWQpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gTGlnaHR3ZWlnaHQgY29uY3VycmVuY3kgbGltaXRlclxyXG5hc3luYyBmdW5jdGlvbiB3aXRoQ29uY3VycmVuY3k8VD4oaXRlbXM6IFRbXSwgbGltaXQ6IG51bWJlciwgd29ya2VyOiAoaXRlbTogVCwgaWR4OiBudW1iZXIpID0+IFByb21pc2U8dm9pZD4pIHtcclxuICBjb25zdCBleGVjdXRpbmc6IFByb21pc2U8dm9pZD5bXSA9IFtdO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IHAgPSB3b3JrZXIoaXRlbXNbaV0sIGkpO1xyXG4gICAgZXhlY3V0aW5nLnB1c2gocCk7XHJcbiAgICBpZiAoZXhlY3V0aW5nLmxlbmd0aCA+PSBsaW1pdCkge1xyXG4gICAgICBhd2FpdCBQcm9taXNlLnJhY2UoZXhlY3V0aW5nKS5jYXRjaCgoKSA9PiB1bmRlZmluZWQpO1xyXG4gICAgICAvLyByZW1vdmUgc2V0dGxlZFxyXG4gICAgICBmb3IgKGxldCBqID0gZXhlY3V0aW5nLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgaWYgKChleGVjdXRpbmdbal0gYXMgYW55KS5zZXR0bGVkKSBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICAvLyBjb21wYWN0IGJ5IGZpbHRlcmluZyBzZXR0bGVkIHByb21pc2VzXHJcbiAgICAgIGZvciAobGV0IGsgPSBleGVjdXRpbmcubGVuZ3RoIC0gMTsgayA+PSAwOyBrLS0pIHtcclxuICAgICAgICBpZiAoKGV4ZWN1dGluZ1trXSBhcyBhbnkpLl9fZG9uZV9fKSB7XHJcbiAgICAgICAgICBleGVjdXRpbmcuc3BsaWNlKGssIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbWFyayBjb21wbGV0aW9uXHJcbiAgICBwLnRoZW4oKCkgPT4gKChwIGFzIGFueSkuX19kb25lX18gPSB0cnVlKSwgKCkgPT4gKChwIGFzIGFueSkuX19kb25lX18gPSB0cnVlKSk7XHJcbiAgfVxyXG4gIC8vIGF3YWl0IHJlbWFpbmluZ1xyXG4gIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChleGVjdXRpbmcpO1xyXG59XHJcblxyXG5jbGFzcyBQcm9iZUxhdGVuY3lTZXJ2aWNlIHtcclxuICBpbnRlcnZhbCA9IDUwMDA7XHJcbiAgc3Vic2NyaWJlcnM6IFN1YnNjcmliZXJbXSA9IFtdO1xyXG4gIGhpc3Rvcnk6IFJlY29yZDxQYWlyS2V5LCBMYXRlbmN5UG9pbnRbXT4gPSB7fTtcclxuICBwcml2YXRlIF90aW1lcjogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gIHByaXZhdGUgcnVubmluZyA9IGZhbHNlO1xyXG4gIHByaXZhdGUgdGlja2luZyA9IGZhbHNlOyAvLyBwcmV2ZW50IG92ZXJsYXBwaW5nIHRpY2tzXHJcblxyXG4gIHN0YXJ0KCkge1xyXG4gICAgaWYgKHRoaXMucnVubmluZykgcmV0dXJuO1xyXG4gICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBzZWVkIGhpc3RvcnkgZm9yIHBhaXJzXHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBFWENIQU5HRV9TRVJWRVJTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgRVhDSEFOR0VfU0VSVkVSUy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGlmIChpID09PSBqKSBjb250aW51ZTtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmtleShFWENIQU5HRV9TRVJWRVJTW2ldLmlkLCBFWENIQU5HRV9TRVJWRVJTW2pdLmlkKTtcclxuICAgICAgICBpZiAoIXRoaXMuaGlzdG9yeVtrZXldKSB7XHJcbiAgICAgICAgICB0aGlzLmhpc3Rvcnlba2V5XSA9IFtdO1xyXG4gICAgICAgICAgZm9yIChsZXQgayA9IDYwOyBrID49IDA7IGstLSkge1xyXG4gICAgICAgICAgICBjb25zdCB0cyA9IG5vdyAtIGsgKiB0aGlzLmludGVydmFsO1xyXG4gICAgICAgICAgICBjb25zdCBtcyA9IHRoaXMuc3ludGhldGljTGF0ZW5jeShFWENIQU5HRV9TRVJWRVJTW2ldLCBFWENIQU5HRV9TRVJWRVJTW2pdKTtcclxuICAgICAgICAgICAgdGhpcy5oaXN0b3J5W2tleV0ucHVzaCh7IHRzLCBtcyB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRpY2soKTtcclxuICB9XHJcblxyXG4gIHN0b3AoKSB7XHJcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgIGlmICh0aGlzLl90aW1lciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XHJcbiAgICAgIHRoaXMuX3RpbWVyID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3Vic2NyaWJlKGNiOiBTdWJzY3JpYmVyKSB7XHJcbiAgICB0aGlzLnN1YnNjcmliZXJzLnB1c2goY2IpO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IHRoaXMuc3Vic2NyaWJlcnMuZmlsdGVyKChzKSA9PiBzICE9PSBjYik7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZ2V0SGlzdG9yeShmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcsIHNpbmNlVHM/OiBudW1iZXIpIHtcclxuICAgIGNvbnN0IGtleSA9IHRoaXMua2V5KGZyb20sIHRvKTtcclxuICAgIGNvbnN0IGggPSB0aGlzLmhpc3Rvcnlba2V5XSB8fCBbXTtcclxuICAgIGlmICghc2luY2VUcykgcmV0dXJuIGg7XHJcbiAgICByZXR1cm4gaC5maWx0ZXIoKHApID0+IHAudHMgPj0gc2luY2VUcyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGtleShhOiBzdHJpbmcsIGI6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIGAke2F9X18ke2J9YDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgdGljaygpIHtcclxuICAgIGlmICh0aGlzLnRpY2tpbmcpIHtcclxuICAgICAgLy8gcHJldmVudCBvdmVybGFwOyBzY2hlZHVsZSBuZXh0XHJcbiAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcclxuICAgICAgICB0aGlzLl90aW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMudGljaygpLCB0aGlzLmludGVydmFsKSBhcyB1bmtub3duIGFzIG51bWJlcjtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLnRpY2tpbmcgPSB0cnVlO1xyXG5cclxuICAgIGNvbnN0IHVwZGF0ZXM6IExhdGVuY3lVcGRhdGVbXSA9IFtdO1xyXG5cclxuICAgIC8vIEJ1aWxkIHRhc2sgbGlzdCBvbmNlXHJcbiAgICB0eXBlIFRhc2sgPSB7IGZyb206IEV4Y2hhbmdlU2VydmVyOyB0bzogRXhjaGFuZ2VTZXJ2ZXI7IHByb2JlSG9zdHM6IHN0cmluZ1tdIH07XHJcbiAgICBjb25zdCB0YXNrczogVGFza1tdID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBFWENIQU5HRV9TRVJWRVJTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgRVhDSEFOR0VfU0VSVkVSUy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGlmIChpID09PSBqKSBjb250aW51ZTtcclxuICAgICAgICBjb25zdCBmcm9tID0gRVhDSEFOR0VfU0VSVkVSU1tpXTtcclxuICAgICAgICBjb25zdCB0byA9IEVYQ0hBTkdFX1NFUlZFUlNbal07XHJcblxyXG4gICAgICAgIC8vIElmIHlvdSBsYXRlciBhZGQgcHJvYmVzPzogc3RyaW5nW10gdG8gRXhjaGFuZ2VTZXJ2ZXIsIHNhZmVseSBjb21iaW5lIGFuZCBkZWR1cGUgaGVyZS5cclxuICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcbiAgICAgICAgLy8gRXhhbXBsZSAodW5jb21tZW50IHdoZW4gcHJvYmVzIGV4aXN0KTpcclxuICAgICAgICAvLyAoZnJvbS5wcm9iZXMgPz8gW10pLmZvckVhY2goKHUpID0+IGNhbmRpZGF0ZXMuYWRkKHUpKTtcclxuICAgICAgICAvLyAodG8ucHJvYmVzID8/IFtdKS5mb3JFYWNoKCh1KSA9PiBjYW5kaWRhdGVzLmFkZCh1KSk7XHJcblxyXG4gICAgICAgIHRhc2tzLnB1c2goeyBmcm9tLCB0bywgcHJvYmVIb3N0czogQXJyYXkuZnJvbShjYW5kaWRhdGVzKSB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFdvcmtlciBleGVjdXRlcyBwZXIgcGFpclxyXG4gICAgY29uc3Qgd29ya2VyID0gYXN5bmMgKHRhc2s6IFRhc2spID0+IHtcclxuICAgICAgY29uc3QgeyBmcm9tLCB0bywgcHJvYmVIb3N0cyB9ID0gdGFzaztcclxuICAgICAgbGV0IG1zOiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFByb2JlIHRocm91Z2ggY2FuZGlkYXRlcyBpZiBhbnk7IGVsc2UgdXNlIHN5bnRoZXRpY1xyXG4gICAgICBmb3IgKGNvbnN0IHVybCBvZiBwcm9iZUhvc3RzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHJ0dCA9IGF3YWl0IHByb2JlVXJsKHVybCwgMjAwMCk7XHJcbiAgICAgICAgICBtcyA9IHJ0dDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgLy8gdHJ5IG5leHQgY2FuZGlkYXRlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobXMgPT09IG51bGwpIHtcclxuICAgICAgICBtcyA9IHRoaXMuc3ludGhldGljTGF0ZW5jeShmcm9tLCB0byk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5KGZyb20uaWQsIHRvLmlkKTtcclxuICAgICAgY29uc3QgcG9pbnQgPSB7IHRzOiBEYXRlLm5vdygpLCBtcyB9O1xyXG4gICAgICBpZiAoIXRoaXMuaGlzdG9yeVtrZXldKSB0aGlzLmhpc3Rvcnlba2V5XSA9IFtdO1xyXG4gICAgICB0aGlzLmhpc3Rvcnlba2V5XS5wdXNoKHBvaW50KTtcclxuICAgICAgaWYgKHRoaXMuaGlzdG9yeVtrZXldLmxlbmd0aCA+IDE1MDApIHRoaXMuaGlzdG9yeVtrZXldLnNoaWZ0KCk7XHJcblxyXG4gICAgICB1cGRhdGVzLnB1c2goeyBmcm9tOiBmcm9tLmlkLCB0bzogdG8uaWQsIG1zIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDb25zdHJhaW4gY29uY3VycmVuY3k7IDEwIGlzIGNvbnNlcnZhdGl2ZSBmb3IgYnJvd3NlcnNcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHdpdGhDb25jdXJyZW5jeSh0YXNrcywgMTAsIHdvcmtlcik7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgLy8gc3dhbGxvdzsgZGVtby1mcmllbmRseVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh1cGRhdGVzLmxlbmd0aCkge1xyXG4gICAgICAvLyBOb3RpZnkgc3Vic2NyaWJlcnNcclxuICAgICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKChzKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHModXBkYXRlcyk7XHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICAvLyBpZ25vcmUgc3Vic2NyaWJlciBlcnJvcnNcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudGlja2luZyA9IGZhbHNlO1xyXG5cclxuICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcclxuICAgICAgdGhpcy5fdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLnRpY2soKSwgdGhpcy5pbnRlcnZhbCkgYXMgdW5rbm93biBhcyBudW1iZXI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN5bnRoZXRpY0xhdGVuY3koYTogRXhjaGFuZ2VTZXJ2ZXIsIGI6IEV4Y2hhbmdlU2VydmVyKSB7XHJcbiAgICBjb25zdCBkaXN0S20gPSBoYXZlcnNpbmUoYSwgYik7XHJcbiAgICAvLyBCYXNlOiBkaXN0YW5jZS1iYXNlZCArIHNtYWxsIG5vaXNlXHJcbiAgICBjb25zdCBiYXNlID0gTWF0aC5tYXgoNSwgZGlzdEttICogMC42ICsgTWF0aC5yYW5kb20oKSAqIDIwKTtcclxuICAgIC8vIENyb3NzLXByb3ZpZGVyIHBlbmFsdHkgdG8gc2ltdWxhdGUgaW50ZXItY2xvdWQgcGF0aHNcclxuICAgIGNvbnN0IHByb3ZpZGVyUGVuYWx0eSA9IGEucHJvdmlkZXIgIT09IGIucHJvdmlkZXIgPyA4ICsgTWF0aC5yYW5kb20oKSAqIDE4IDogMDtcclxuICAgIHJldHVybiBNYXRoLnJvdW5kKGJhc2UgKyBwcm92aWRlclBlbmFsdHkpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGxhdGVuY3lQcm92aWRlciA9IG5ldyBQcm9iZUxhdGVuY3lTZXJ2aWNlKCk7XHJcbiJdLCJuYW1lcyI6WyJFWENIQU5HRV9TRVJWRVJTIiwiaGF2ZXJzaW5lIiwiYSIsImIiLCJ0b1JhZCIsImQiLCJNYXRoIiwiUEkiLCJSIiwiZExhdCIsImxhdGl0dWRlIiwiZExvbiIsImxvbmdpdHVkZSIsImxhdDEiLCJsYXQyIiwic2luRGxhdCIsInNpbiIsInNpbkRsb24iLCJ2IiwiY29zIiwiYyIsImF0YW4yIiwic3FydCIsIkhPU1RfQ0FDSEVfVFRMX01TIiwiaG9zdENhY2hlIiwiTWFwIiwicHJvYmVVcmwiLCJ1cmwiLCJ0aW1lb3V0TXMiLCJob3N0IiwiVVJMIiwiaG9zdG5hbWUiLCJjYWNoZWQiLCJnZXQiLCJub3ciLCJEYXRlIiwidHMiLCJtcyIsImFwaVVybCIsImVuY29kZVVSSUNvbXBvbmVudCIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJpZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsInJlc3BvbnNlIiwiZmV0Y2giLCJjYWNoZSIsImNyZWRlbnRpYWxzIiwibW9kZSIsInNpZ25hbCIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJkYXRhIiwianNvbiIsImNhdGNoIiwibGF0ZW5jeSIsIk5hTiIsIk51bWJlciIsImlzRmluaXRlIiwibWF4Iiwicm91bmQiLCJzZXQiLCJjbGVhclRpbWVvdXQiLCJ3aXRoQ29uY3VycmVuY3kiLCJpdGVtcyIsImxpbWl0Iiwid29ya2VyIiwiZXhlY3V0aW5nIiwiaSIsImxlbmd0aCIsInAiLCJwdXNoIiwiUHJvbWlzZSIsInJhY2UiLCJ1bmRlZmluZWQiLCJqIiwic2V0dGxlZCIsImsiLCJfX2RvbmVfXyIsInNwbGljZSIsInRoZW4iLCJhbGxTZXR0bGVkIiwiUHJvYmVMYXRlbmN5U2VydmljZSIsInN0YXJ0IiwicnVubmluZyIsImtleSIsImhpc3RvcnkiLCJpbnRlcnZhbCIsInN5bnRoZXRpY0xhdGVuY3kiLCJ0aWNrIiwic3RvcCIsIl90aW1lciIsInN1YnNjcmliZSIsImNiIiwic3Vic2NyaWJlcnMiLCJmaWx0ZXIiLCJzIiwiZ2V0SGlzdG9yeSIsImZyb20iLCJ0byIsInNpbmNlVHMiLCJoIiwidGlja2luZyIsIndpbmRvdyIsInVwZGF0ZXMiLCJ0YXNrcyIsImNhbmRpZGF0ZXMiLCJTZXQiLCJwcm9iZUhvc3RzIiwiQXJyYXkiLCJ0YXNrIiwicnR0IiwicG9pbnQiLCJzaGlmdCIsImZvckVhY2giLCJkaXN0S20iLCJiYXNlIiwicmFuZG9tIiwicHJvdmlkZXJQZW5hbHR5IiwicHJvdmlkZXIiLCJsYXRlbmN5UHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/latencyProvider.ts\n"));

/***/ })

});