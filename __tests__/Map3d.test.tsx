// Code Generated by Sidekick is for learning and experimentation purposes only.

// All jest.mock() calls go first!
jest.mock("../data/exchanges", () => {
  const EXCHANGE_SERVERS = [
    {
      id: "ex1",
      name: "Exchange One",
      provider: "AWS",
      region: "us-east-1",
      city: "Ashburn",
      latitude: 39.0438,
      longitude: -77.4874,
    },
    {
      id: "ex2",
      name: "Exchange Two",
      provider: "GCP",
      region: "us-west-2",
      city: "San Francisco",
      latitude: 37.7749,
      longitude: -122.4194,
    },
    {
      id: "ex3",
      name: "Exchange Three",
      provider: "Azure",
      region: "eu-central-1",
      city: "Frankfurt",
      latitude: 50.1109,
      longitude: 8.6821,
    },
  ];
  return { EXCHANGE_SERVERS };
});

let subscriberCallback: ((updates: { from: string; to: string; ms: number }[]) => void) | null = null;
const subscribe = jest.fn((cb: any) => {
  subscriberCallback = cb;
  return () => { subscriberCallback = null; }; // For unmount/unsubscribe
});
// Just plain fn mocks for start/stop
const start = jest.fn();
const stop = jest.fn();

jest.mock("../lib/latencyProvider", () => ({
  latencyProvider: {
    start,
    stop,
    subscribe,
    history: {},
  },
}));

// Polyfills
if (!("ResizeObserver" in global)) {
  class ResizeObserver {
    observe() {}
    unobserve() {}
    disconnect() {}
  }
  // @ts-ignore
  global.ResizeObserver = ResizeObserver;
}
if (!("createObjectURL" in URL)) {
  Object.defineProperty(URL, "createObjectURL", {
    writable: true,
    configurable: true,
    value: jest.fn(() => "blob:mock-url"),
  });
}
if (!("revokeObjectURL" in URL)) {
  Object.defineProperty(URL, "revokeObjectURL", {
    writable: true,
    configurable: true,
    value: jest.fn(),
  });
}
if (! HTMLCanvasElement.prototype.getContext) {
  // @ts-ignore
  HTMLCanvasElement.prototype.getContext = jest.fn(() => ({} as any));
}
if (! HTMLCanvasElement.prototype.toDataURL) {
  // @ts-ignore
  HTMLCanvasElement.prototype.toDataURL = jest.fn(() => "data:image/png;base64,xxx");
}

// Imports AFTER ALL mocks above
import React from "react";
import { render, screen, fireEvent, waitFor, act } from "@testing-library/react";
import { AppContext } from "../lib/appContext";
import Map3D from "../components/Map3D";
import { latencyProvider } from "../lib/latencyProvider"; // This now refers to the mock above

// Context mock (unchanged)
const mockAppContextValue = {
  providers: { AWS: true, GCP: true, Azure: true },
  selectedExchange: null,
  searchQ: "",
  highlightedPair: null,
  latencyData: [],
  allUpdates: [],
  setProviders: jest.fn(),
  toggleProvider: jest.fn(),
  setSelectedExchange: jest.fn(),
  setSearchQ: jest.fn(),
  setHighlightedPair: jest.fn(),
};

function setup(
  overrides?: Partial<React.ComponentProps<typeof Map3D>>,
  contextOverride?: Partial<typeof mockAppContextValue>
) {
  const onSelect = jest.fn();
  const props: React.ComponentProps<typeof Map3D> = {
    filterProviders: { AWS: true, GCP: true, Azure: true },
    onSelect,
    highlightedPair: null,
    ...overrides,
  };
  const contextValue = { ...mockAppContextValue, ...contextOverride };
  const utils = render(
    <AppContext.Provider value={contextValue}>
      <div style={{ width: 800, height: 600 }}>
        <Map3D {...props} />
      </div>
    </AppContext.Provider>
  );
  return { ...utils, onSelect, props };
}

// Track/cleanup
beforeAll(() => {
  jest.spyOn(console, "error").mockImplementation(() => {});
});
afterAll(() => {
  (console.error as jest.Mock).mockRestore();
});
afterEach(() => {
  (console.error as jest.Mock).mockClear();
  jest.clearAllMocks();
  subscriberCallback = null;
});

// TESTS!

describe("Map3D", () => {
  it("renders the Canvas and core scene elements (lights, globe, regions) without crashing", async () => {
    setup();
    const canvas = document.querySelector("canvas");
    expect(canvas).toBeTruthy();
    await waitFor(() => {
      expect(latencyProvider.subscribe).toHaveBeenCalled();
    });
  });

  it("subscribes to latency updates on mount and unsubscribes on unmount", () => {
    const { unmount } = setup();
    expect(latencyProvider.subscribe).toHaveBeenCalled();
    unmount();
    expect(subscriberCallback).toBeNull();
  });

  it("updates GPU arcs when latency updates arrive and respects provider filters", async () => {
    setup({ filterProviders: { AWS: true, GCP: false, Azure: true } });
    act(() => {
      subscriberCallback?.([
        { from: "ex1", to: "ex2", ms: 42 },
        { from: "ex3", to: "ex1", ms: 120 },
      ]);
    });
    await waitFor(() => {
      const canvas = document.querySelector("canvas");
      expect(canvas).toBeTruthy();
    });
    expect((console.error as jest.Mock)).not.toHaveBeenCalled();
  });

  it("renders region visualization based on exchange regions", async () => {
    setup();
    await waitFor(() => {
      const canvas = document.querySelector("canvas");
      expect(canvas).toBeTruthy();
    });
  });

  it.skip("invokes onSelect when clicking a marker label (Html overlay)", async () => {
    const { onSelect } = setup();
    const canvas = document.querySelector("canvas")!;
    fireEvent.pointerDown(canvas);
    act(() => {
      subscriberCallback?.([{ from: "ex1", to: "ex2", ms: 10 }]);
    });
    expect(onSelect).toHaveBeenCalledTimes(0);
  });

  it("handles highlightedPair prop without errors", async () => {
    setup({ highlightedPair: { from: "ex1", to: "ex2" } });
    act(() => {
      subscriberCallback?.([{ from: "ex1", to: "ex2", ms: 33 }]);
    });
    await waitFor(() => {
      const canvas = document.querySelector("canvas");
      expect(canvas).toBeTruthy();
    });
    expect((console.error as jest.Mock)).not.toHaveBeenCalled();
  });

  it("does not crash when texture fails to load", async () => {
    const realImage = (global as any). Image;
    (global as any). Image = class {
      set src(_v: string) {}
    };
    setup();
    await waitFor(() => {
      const canvas = document.querySelector("canvas");
      expect(canvas).toBeTruthy();
    });
    (global as any). Image = realImage;
  });
});
