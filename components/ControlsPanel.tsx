// Code Generated by Sidekick is for learning and experimentation purposes only.
// ControlsPanel.tsx ‚Äî with CSV and PNG export features
import React, { useEffect, useMemo, useRef, useState } from "react";
import { EXCHANGE_SERVERS, Provider, ExchangeServer } from "../data/exchanges";
import { latencyProvider } from "../lib/latencyProvider";


type Props = {
  providers: Record<string, boolean>;
  onToggleProvider: (p: Provider) => void;
  onSelectExchange: (id: string | null) => void;
  selectedExchange: string | null;
  onSearch: (q: string) => void;
};

type LatencyMap = Record<string, number | undefined>;
type TimeRangeKey = "1h" | "24h" | "7d" | "30d";
type LatencyPoint = { ts: number; ms: number };
type HistorySample = { from: string; to: string; ts: number; ms: number };

// Matches typical provider "Subscriber" payload (no ts on live updates)
type LatencyUpdate = { from: string; to: string; ms: number };

// ----- helpers: time range, stats, chart, history adapters -----

function timeRangeToWindow(range: TimeRangeKey) {
  const now = Date.now();
  switch (range) {
    case "1h": return { start: now - 60 * 60 * 1000, end: now };
    case "24h": return { start: now - 24 * 60 * 60 * 1000, end: now };
    case "7d": return { start: now - 7 * 24 * 60 * 60 * 1000, end: now };
    case "30d": return { start: now - 30 * 24 * 60 * 60 * 1000, end: now };
  }
}

function computeStats(points: LatencyPoint[]) {
  if (!points.length) return { min: null as number | null, max: null as number | null, avg: null as number | null };
  let min = Infinity;
  let max = -Infinity;
  let sum = 0;
  for (const p of points) {
    if (p.ms < min) min = p.ms;
    if (p.ms > max) max = p.ms;
    sum += p.ms;
  }
  return { min, max, avg: sum / points.length };
}

type SimpleTrendProps = { points: LatencyPoint[]; width?: number; height?: number };
const SimpleTrend = React.forwardRef<SVGSVGElement, SimpleTrendProps>(function SimpleTrendInner(
  { points, width = 600, height = 160 },
  ref
) {
  const padding = { top: 8, right: 12, bottom: 22, left: 36 };

  const { path, xTicks, yTicks } = useMemo(() => {
    if (!points.length) return { path: "", xTicks: [] as { x: number; label: string }[], yTicks: [] as { y: number; label: string }[] };

    const sorted = [...points].sort((a, b) => a.ts - b.ts);
    const xs = sorted.map((p) => p.ts);
    const ys = sorted.map((p) => p.ms);

    const xMin = Math.min(...xs);
    const xMax = Math.max(...xs);
    const yMin = Math.min(...ys);
    const yMax = Math.max(...ys);

    const iw = width - padding.left - padding.right;
    const ih = height - padding.top - padding.bottom;

    const xScale = (x: number) => padding.left + ((x - xMin) / (xMax - xMin || 1)) * iw;
    const yScale = (y: number) => padding.top + (1 - (y - yMin) / (yMax - yMin || 1)) * ih;

    let d = "";
    sorted.forEach((p, i) => {
      const X = xScale(p.ts);
      const Y = yScale(p.ms);
      d += i === 0 ? `M ${X} ${Y}` : ` L ${X} ${Y}`;
    });

    const xTicks = [
      { x: xScale(xMin), label: new Date(xMin).toLocaleTimeString() },
      { x: xScale(xMax), label: new Date(xMax).toLocaleTimeString() }
    ];
    const yTicks = [
      { y: yScale(yMin), label: `${Math.round(yMin)} ms` },
      { y: yScale(yMax), label: `${Math.round(yMax)} ms` }
    ];

    return { path: d, xTicks, yTicks };
  }, [points, width, height]);

  return (
    <svg ref={ref} width={width} height={height} role="img" aria-label="Historical latency trend" style={{ display: "block", width: "100%" }}>
      <line x1={padding.left} y1={height - padding.bottom} x2={width - padding.right} y2={height - padding.bottom} stroke="rgba(255,255,255,0.2)" />
      <line x1={padding.left} y1={padding.top} x2={padding.left} y2={height - padding.bottom} stroke="rgba(255,255,255,0.2)" />
      <path d={path} stroke="#1f6feb" strokeWidth={1.5} fill="none" />
      {xTicks.map((t, i) => (
        <g key={i} transform={`translate(${t.x}, ${height - padding.bottom})`}>
          <line y2="6" stroke="rgba(255,255,255,0.2)" />
          <text y="18" fill="#ddd" fontSize="11" textAnchor="middle">{t.label}</text>
        </g>
      ))}
      {yTicks.map((t, i) => (
        <g key={i} transform={`translate(${padding.left}, ${t.y})`}>
          <line x2="-6" stroke="rgba(255,255,255,0.2)" />
          <text x="-10" fill="#ddd" fontSize="11" textAnchor="end" dominantBaseline="middle">{t.label}</text>
        </g>
      ))}
    </svg>
  );
});

// History can be either a function or a map-like object.
type HistoryFn = (args: { from?: string | null; to?: string | null; start: number; end: number }) => Promise<HistorySample[]>;
function isHistoryFn(x: unknown): x is HistoryFn {
  return typeof x === "function";
}
function readHistoryFromMap(
  map: Record<string, LatencyPoint[]>,
  opts: { from?: string | null; to?: string | null; start: number; end: number }
): HistorySample[] {
  const result: HistorySample[] = [];
  for (const key of Object.keys(map)) {
    const parts = key.split("->");
    const kf = parts[0];
    const kt = parts[1];
    if (opts.from && kf !== opts.from) continue;
    if (opts.to && kt !== opts.to) continue;
    const arr = map[key] ?? [];
    for (const p of arr) {
      if (p.ts >= opts.start && p.ts <= opts.end) {
        result.push({ from: kf, to: kt, ts: p.ts, ms: p.ms });
      }
    }
  }
  return result.sort((a, b) => a.ts - b.ts);
}

// ----- component -----

export default function ControlsPanel({
  providers,
  onToggleProvider,
  onSelectExchange,
  selectedExchange,
  onSearch
}: Props) {
  const [q, setQ] = useState("");
  const [live, setLive] = useState(true);
  const [latency, setLatency] = useState<LatencyMap>({});
  const [timeRange, setTimeRange] = useState<TimeRangeKey>("24h");
  const [historyPoints, setHistoryPoints] = useState<LatencyPoint[]>([]);
  const [loadingHistory, setLoadingHistory] = useState(false);
  const debounceRef = useRef<number | undefined>(undefined);

  // Chart ref for PNG export
  const chartRef = useRef<SVGSVGElement | null>(null);

  // Anchor is the selected exchange or the first in the list
  const anchorId = useMemo<string | null>(() => {
    if (selectedExchange) return selectedExchange;
    return EXCHANGE_SERVERS.length ? EXCHANGE_SERVERS[0].id : null;
  }, [selectedExchange]);

  // Subscribe to latency updates and keep latest RTT map from anchor -> others
  useEffect(() => {
    latencyProvider.start();
    const unsubscribe = latencyProvider.subscribe((updates: LatencyUpdate[]) => {
      if (!anchorId) return;
      const rel = updates.filter((u) => u.from === anchorId);
      if (rel.length === 0) return;
      setLatency((prev) => {
        const next = { ...prev };
        for (const u of rel) next[u.to] = u.ms;
        return next;
      });
    });
    return () => unsubscribe();
  }, [anchorId]);

  // Debounce search forwarding
  useEffect(() => {
    window.clearTimeout(debounceRef.current);
    debounceRef.current = window.setTimeout(() => onSearch(q), 200);
    return () => window.clearTimeout(debounceRef.current);
  }, [q, onSearch]);

  // Compute visible exchanges
  const visibleExchanges: ExchangeServer[] = useMemo(() => {
    const norm = q.trim().toLowerCase();
    const filtered = EXCHANGE_SERVERS.filter((s) => {
      const providerOk = providers[s.provider] ?? true;
      const matches =
        !norm ||
        s.name.toLowerCase().includes(norm) ||
        s.city?.toLowerCase().includes(norm) ||
        s.region.toLowerCase().includes(norm);
      return providerOk && matches;
    });

    type Scored = { s: ExchangeServer; score: number };
    const withScore: Scored[] = filtered.map((s) => {
      const score =
        s.id === selectedExchange
          ? Number.NEGATIVE_INFINITY
          : latency[s.id] !== undefined
          ? Number(latency[s.id])
          : Number.POSITIVE_INFINITY;
      return { s, score };
    });

    withScore.sort((a, b) => {
      if (a.score === b.score) return a.s.name.localeCompare(b.s.name);
      return a.score - b.score;
    });

    return withScore.map((x) => x.s);
  }, [q, providers, latency, selectedExchange]);

  // Live toggle
  const toggleLive = () => {
    setLive((v) => {
      const next = !v;
      if (next) latencyProvider.start();
      else latencyProvider.stop();
      return next;
    });
  };

  // Provider counts
  const providerCounts = useMemo(() => {
    const counts: Record<Provider, number> = { AWS: 0, GCP: 0, Azure: 0 };
    for (const s of EXCHANGE_SERVERS) counts[s.provider]++;
    return counts;
  }, []);

  // Fetch historical latency for current anchor selection
  useEffect(() => {
    const run = async () => {
      setLoadingHistory(true);
      try {
        if (!anchorId) {
          setHistoryPoints([]);
          return;
        }
        const { start, end } = timeRangeToWindow(timeRange);

        const rawHistory = (latencyProvider as any).history;
        let raw: HistorySample[] = [];

        if (isHistoryFn(rawHistory)) {
          raw = await rawHistory({ from: anchorId, to: null, start, end });
        } else if (rawHistory && typeof rawHistory === "object") {
          raw = readHistoryFromMap(rawHistory as Record<string, LatencyPoint[]>, { from: anchorId, to: null, start, end });
        } else {
          raw = [];
        }

        const byTs = new Map<number, number[]>();
        for (const d of raw) {
          if (d.from !== anchorId) continue;
          if (! Number.isFinite(d.ms)) continue;
          if (!byTs.has(d.ts)) byTs.set(d.ts, []);
          byTs.get(d.ts)!.push(d.ms);
        }
        const aggregated: LatencyPoint[] = Array.from(byTs.entries())
          .map(([ts, arr]) => ({ ts, ms: arr.reduce((a, b) => a + b, 0) / arr.length }))
          .sort((a, b) => a.ts - b.ts);

        setHistoryPoints(aggregated);
      } catch {
        setHistoryPoints([]);
      } finally {
        setLoadingHistory(false);
      }
    };
    run();
  }, [anchorId, timeRange]);

  const stats = useMemo(() => computeStats(historyPoints), [historyPoints]);

  // ----- Export handlers -----

  function handleExportLiveSnapshotCsv() {
    const rows = Object.entries(latency).map(([to, ms]) => ({
      from: anchorId ?? "",
      to,
      ms: ms ?? "",
      exported_at: new Date().toISOString()
    }));
    const csv = toCsv(rows);
    downloadTextFile(`latency_snapshot_${anchorId ?? "na"}_${Date.now()}.csv`, csv);
  }

  function handleExportHistoryCsv() {
    const rows = historyPoints.map((p) => ({
      from: anchorId ?? "",
      to: "aggregate",
      ts: p.ts,
      iso_time: new Date(p.ts).toISOString(),
      ms: p.ms,
      range: timeRange
    }));
    const csv = toCsv(rows);
    downloadTextFile(`latency_history_${anchorId ?? "na"}_${timeRange}_${Date.now()}.csv`, csv);
  }

  async function handleExportChartPng() {
    if (!chartRef.current) return;
    await exportSvgElementToPng(chartRef.current, `latency_chart_${anchorId ?? "na"}_${timeRange}.png`);
  }

  return (
    <div>
      {/* Header: Title + Actions */}
      <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 8, marginBottom: 16 }}>
        <h3 style={{ margin: 0, fontSize: "18px", fontWeight: "700", color: "#e6edf3" }}>Latency Topology Visualizer</h3>
        <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
          <span
            aria-live="polite"
            style={{
              fontSize: 12,
              fontWeight: "600",
              opacity: 0.9,
              padding: "4px 10px",
              borderRadius: 12,
              border: "1px solid rgba(255,255,255,0.15)",
              background: live ? "linear-gradient(135deg, rgba(46, 160, 67, 0.2) 0%, rgba(46, 160, 67, 0.1) 100%)" : "linear-gradient(135deg, rgba(240, 84, 84, 0.2) 0%, rgba(240, 84, 84, 0.1) 100%)",
              boxShadow: "0 2px 4px rgba(0,0,0,0.3)"
            }}
            title={live ? "Live probing running" : "Probing paused"}
          >
            {live ? "‚óè Live" : "‚è∏ Paused"}
          </span>
          <button
            aria-pressed={live}
            onClick={toggleLive}
            style={{
              fontSize: 12,
              fontWeight: "600",
              padding: "8px 12px",
              borderRadius: 8,
              background: "linear-gradient(135deg, rgba(56, 139, 253, 0.1) 0%, rgba(56, 139, 253, 0.05) 100%)",
              color: "#58a6ff",
              border: "1px solid rgba(56, 139, 253, 0.3)",
              cursor: "pointer",
              minHeight: 36,
              transition: "all 0.2s ease",
              boxShadow: "0 2px 4px rgba(0,0,0,0.2)"
            }}
          >
            {live ? "‚è∏ Pause" : "‚ñ∂ Resume"}
          </button>

          {/* Export actions */}
          <button
            onClick={handleExportLiveSnapshotCsv}
            style={{
              fontSize: 12,
              fontWeight: "600",
              padding: "8px 12px",
              borderRadius: 8,
              background: "linear-gradient(135deg, rgba(187, 128, 9, 0.1) 0%, rgba(187, 128, 9, 0.05) 100%)",
              color: "#d29922",
              border: "1px solid rgba(187, 128, 9, 0.3)",
              cursor: "pointer",
              minHeight: 36,
              transition: "all 0.2s ease",
              boxShadow: "0 2px 4px rgba(0,0,0,0.2)"
            }}
            title="Export current live latency report"
          >
            üìä Export CSV
          </button>
        </div>
      </div>

      {/* Search */}
      <div style={{ marginTop: 12 }}>
        <form onSubmit={(e) => e.preventDefault()} role="search" aria-label="Search exchanges" style={{ margin: 0 }}>
          <input
            placeholder="Search exchange..."
            value={q}
            aria-label="Search exchange"
            style={{
              width: "100%",
              padding: 8,
              borderRadius: 6,
              border: "1px solid rgba(255,255,255,0.06)",
              background: "transparent",
              color: "#fff"
            }}
            onChange={(e) => setQ(e.target.value)}
          />
        </form>

        {/* Provider filters */}
        <div style={{ marginTop: 8 }}>
          <strong>Providers</strong>
          <div style={{ display: "flex", gap: 12, marginTop: 8 }}>
            {(["AWS", "GCP", "Azure"] as Provider[]).map((p) => (
              <label key={p} style={{ display: "flex", alignItems: "center", gap: 6 }}>
                <input
                  type="checkbox"
                  checked={!!providers[p]}
                  onChange={() => onToggleProvider(p)}
                  aria-checked={!!providers[p]}
                  aria-label={`Toggle ${p}`}
                />
                <span style={{ color: "#ddd" }}>
                  {p} ({providerCounts[p]})
                </span>
              </label>
            ))}
          </div>
        </div>

        {/* Exchanges list */}
        <div style={{ marginTop: 12 }}>
          <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
            <strong>Exchanges</strong>
            <span style={{ fontSize: 11, opacity: 0.7 }}>
              Showing latency from: {anchorId ?? "N/A"}
            </span>
          </div>

          <div role="list" aria-label="Exchange list" style={{ display: "grid", gap: 6, marginTop: 6 }}>
            {visibleExchanges.map((s) => {
              const isSelected = selectedExchange === s.id;
              const ms = s.id === anchorId ? 0 : latency[s.id];
              const msText = ms === undefined ? "‚Äî" : `${ms} ms`;
              const pillColor =
                ms === undefined
                  ? "rgba(255,255,255,0.08)"
                  : ms < 80
                  ? "rgba(46,160,67,0.2)"
                  : ms < 160
                  ? "rgba(187,128,9,0.25)"
                  : "rgba(240,84,84,0.2)";

              return (
                <button
                  key={s.id}
                  role="listitem"
                  aria-pressed={isSelected}
                  style={{
                    textAlign: "left",
                    padding: "8px 10px",
                    borderRadius: 6,
                    background: isSelected ? "#1f6feb" : "transparent",
                    color: isSelected ? "#fff" : "#ddd",
                    border: "1px solid rgba(255,255,255,0.06)",
                    cursor: "pointer",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "space-between",
                    gap: 10
                  }}
                  onClick={() => onSelectExchange(isSelected ? null : s.id)}
                >
                  <div>
                    <div style={{ fontSize: 14 }}>
                      {s.name} <small style={{ opacity: 0.7 }}>{s.city ? `‚Äî ${s.city}` : ""}</small>
                    </div>
                    <div style={{ fontSize: 11, opacity: 0.7 }}>
                      {s.provider} ¬∑ {s.region}
                    </div>
                  </div>
                  <div
                    title={
                      s.id === anchorId
                        ? "Anchor (self latency)"
                        : ms === undefined
                        ? "No recent data yet"
                        : `Latest RTT from ${anchorId} to ${s.id}`
                    }
                    style={{
                      fontSize: 12,
                      padding: "2px 8px",
                      borderRadius: 10,
                      border: "1px solid rgba(255,255,255,0.1)",
                      background: pillColor,
                      minWidth: 54,
                      textAlign: "right"
                    }}
                  >
                    {s.id === anchorId ? "‚Äî" : msText}
                  </div>
                </button>
              );
            })}
          </div>
        </div>

        {/* Time Range and Historical Chart Section */}
        <div style={{ marginTop: 16 }}>
          <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 8 }}>
            <strong>Historical Latency</strong>
            <div style={{ display: "flex", gap: 8 }}>
              {(["1h", "24h", "7d", "30d"] as TimeRangeKey[]).map((r) => (
                <button
                  key={r}
                  aria-pressed={timeRange === r}
                  onClick={() => setTimeRange(r)}
                  style={{
                    fontSize: 12,
                    padding: "8px 12px",
                    borderRadius: 6,
                    background: timeRange === r ? "#1f6feb" : "transparent",
                    color: timeRange === r ? "#fff" : "#ddd",
                    border: "1px solid rgba(255,255,255,0.2)",
                    cursor: "pointer",
                    minHeight: 36
                  }}
                >
                  {r}
                </button>
              ))}
            </div>
          </div>

          <div
            style={{
              padding: "8px 10px",
              borderRadius: 6,
              border: "1px solid rgba(255,255,255,0.08)",
              background: "rgba(13,17,23,0.6)",
              color: "#ddd"
            }}
          >
            {loadingHistory ? (
              <div style={{ fontSize: 12, opacity: 0.8 }}>Loading historical data‚Ä¶</div>
            ) : historyPoints.length === 0 ? (
              <div style={{ fontSize: 12, opacity: 0.8 }}>No historical data for the selected window.</div>
            ) : (
              <SimpleTrend ref={chartRef} points={historyPoints} />
            )}

            {/* Stats */}
            <div style={{ display: "flex", gap: 16, marginTop: 8, fontSize: 12 }}>
              <div>Min: {stats.min !== null ? `${Math.round(stats.min)} ms` : "‚Äî"}</div>
              <div>Max: {stats.max !== null ? `${Math.round(stats.max)} ms` : "‚Äî"}</div>
              <div>Average: {stats.avg !== null ? `${Math.round(stats.avg)} ms` : "‚Äî"}</div>
            </div>
            <div style={{ fontSize: 11, opacity: 0.7, marginTop: 4 }}>
              Showing anchor-wide average across outgoing links from {anchorId ?? "N/A"} for the selected time range.
            </div>
          </div>
        </div>

        <div style={{ marginTop: 10, fontSize: 11, opacity: 0.7 }}>
          Tip: Select an exchange to set it as the anchor for live comparisons. Use the time range above to analyze historical trends.
        </div>
      </div>
    </div>
  );
}

// ----- lightweight export utils (CSV + PNG from SVG) -----

function toCsv(rows: Record<string, string | number | null | undefined>[]): string {
  if (!rows.length) return "";
  const headers = Object.keys(rows[0]);
  const esc = (val: unknown) => {
    if (val === null || val === undefined) return "";
    const s = String(val);
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
    return s;
  };
  const head = headers.map(esc).join(",");
  const body = rows.map((r) => headers.map((h) => esc(r[h])).join(",")).join("\n");
  return `${head}\n${body}`;
}

function downloadTextFile(filename: string, content: string, mime = "text/csv;charset=utf-8") {
  const blob = new Blob([content], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

async function exportSvgElementToPng(svgEl: SVGSVGElement, filename: string, background = "#0d1117") {
  const serializer = new XMLSerializer();
  const svgData = serializer.serializeToString(svgEl);
  const svgBlob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
  const url = URL.createObjectURL(svgBlob);

  const img = new Image();
  const loaded = await new Promise<void>((resolve, reject) => {
    img.onload = () => resolve();
    img.onerror = reject;
    img.src = url;
  });
  void loaded;

  const box = svgEl.viewBox && svgEl.viewBox.baseVal && svgEl.viewBox.baseVal.width
    ? { width: svgEl.viewBox.baseVal.width, height: svgEl.viewBox.baseVal.height }
    : { width: svgEl.getBoundingClientRect().width || 800, height: svgEl.getBoundingClientRect().height || 400 };

  const canvas = document.createElement("canvas");
  canvas.width = Math.ceil(box.width);
  canvas.height = Math.ceil(box.height);
  const ctx = canvas.getContext("2d");
  if (!ctx) throw new Error("Canvas 2D context not available");

  ctx.fillStyle = background;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

  const dataUrl = canvas.toDataURL("image/png");
  const a = document.createElement("a");
  a.href = dataUrl;
  a.download = filename;
  a.click();

  URL.revokeObjectURL(url);
}
